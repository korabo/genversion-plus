
var makeAbsolute = require('./makeAbsolute')
var path = require('path')
var firstline = require('firstline')
var findPackage = require('find-package')
var fs = require('fs')
var mkdirp = require('mkdirp')

var SIGNATURE = '// generated by genversion-plus'
var BGN_MARKER = /^\[BGN:(.*)\]$/
var FIN_MARKER = /^\[FIN\]$/
var VAR_PLACE_HOLDER = /\$\{(.*?)\}/

var varMap = {}

exports.check = function (targetPath, callback) {
  // Check if a version file can be generated.
  //
  // Parameters
  //   targetPath
  //     relative or absolute filepath to version file.
  //   callback
  //     function (err, doesExist, isByGenversion)
  //       err
  //         non-null on file system error
  //       doesExist
  //         boolean
  //       isByGenversion
  //         boolean, true if file exists and is generated by genversion.
  //         The check is done by comparing the SIGNATURE on the first line.

  var absTarget = makeAbsolute(targetPath)

  // Ensure that target does not exist or if it exists,
  // ensure it was generated by genversion. Otherwise
  // exit with an error.
  firstline(absTarget)
    .then(function (line) {
      if (line.trim() === SIGNATURE) {
        // OK, the existing file was generated by us.
        return callback(null, true, true)
      }
      // Unknown file
      return callback(null, true, false)
    })
    .catch(function (err) {
      if (err.code === 'ENOENT') {
        // OK, file does not exist.
        return callback(null, false, false)
      }
      // Real error.
      return callback(err, false, false)
    })
}

exports.generate = function (targetPath, opts, callback) {
  // Generate version submodule file to targetPath with utf-8 encoding.
  //
  // Parameters:
  //   targetPath
  //     string. absolute or relative path
  //   opts
  //     optional object with optional properties
  //       useSemicolon
  //         bool, true to use semicolons in generated code
  //      genSyntax,source,template,message
  //   callback
  //     function (err, version)
  //       err
  //         null if generated successfully
  //         non-null if no package.json found or version in it is invalid
  //       version
  //         new version string, undefined on error
  //
  var absTarget, absSource, absTemplate, pjson, err, version, buildTime, comment, author

  if (typeof targetPath !== 'string') {
    throw new Error('Unexpected targetPath argument')
  }

  if (typeof callback !== 'function') {
    if (typeof opts !== 'function') {
      throw new Error('Unexpected callback argument')
    } else {
      callback = opts
      opts = {}
    }
  }

  if (typeof opts !== 'object') {
    throw new Error('Unexpected opts argument')
  }

  if (typeof opts.useSemicolon !== 'boolean') {
    opts.useSemicolon = false // default
  }

  if (typeof opts.genSyntax !== 'string') {
    opts.genSyntax = 'cjs' // default
  }

  if (typeof opts.source !== 'string') {
    opts.source = targetPath // default
  }

  if (typeof opts.template !== 'string') {
    opts.template = path.resolve(__dirname, 'template.txt') // default
  }

  if (typeof opts.message !== 'string') {
    opts.message = '' // default
  }

  absTarget = makeAbsolute(targetPath)
  absSource = makeAbsolute(opts.source)
  absTemplate = makeAbsolute(opts.template)

  // Find closest package.json from the target towards filesystem root
  pjson = findPackage(absSource)

  // findPackage returns null if not found
  if (pjson === null) {
    err = new Error('No package.json found along path ' + absSource)
    return callback(err)
  }
  // check template file exists
  if (!fs.existsSync(absTemplate)) {
    err = new Error('No tempalte file found along path ' + absTemplate)
    return callback(err)
  }

  // Get version property
  version = pjson.version
  buildTime = new Date().toISOString()
  comment = opts.message
  author = opts.author || findAuthor(pjson)

  // Ensure version is string
  if (typeof version !== 'string') {
    err = new Error('Invalid version in package.json: ' + version)
    return callback(err)
  }
  // Ensure author.name is string
  if (typeof author !== 'string') {
    err = new Error('Invalid author in package.json: ' + author)
    return callback(err)
  }

  // Ensure directory exists before writing file
  mkdirp(path.dirname(absTarget), function (errp) {
    if (errp) {
      return callback(errp)
    }

    // define code styles use syntax + semicolons
    var genType = opts.genSyntax + (opts.useSemicolon ? '+semi': '')
    varMap['version'] = version
    varMap['buildTime'] = buildTime
    varMap['comment'] = comment
    varMap['author'] = author

    // read target lines btw [BGN:${genType}] --- [FIN]
    var lines = readAllLines(absTemplate)
    var outputs = []
    var inBlock = false
    for (const line of lines) {
      if (inBlock) {
        if (chkFin(line)) break
          // replace vars and push
        outputs.push(replaceVars(line, varMap))
        continue
      }
      // check BGN
      inBlock = chkBgn(line, genType)
    }
    // write SIGNATURE + replaces lines
    var content = SIGNATURE + '\n' + outputs.join('\n')
    fs.writeFile(absTarget, content, 'utf8', function (errw) {
      if (errw) {
        return callback(errw)
      }
      return callback(null, version)
    })
  })
}

// --- Utility functions ---
function findAuthor(pjson) {
  var a = ''
  if (pjson && pjson.author) {
    if (typeof pjson.author === 'string' || pjson.author instanceof String) {
      a = pjson.author
    } else if (pjson.author.name && (typeof pjson.author.name === 'string' || pjson.author.name instanceof String)) {
      a = pjson.author.name
    }
  }
  return a
}
function replaceVars(line, vMap) {
  // replace variables ${} version, buildTime, author, comment
  var l = ''
  if (line) {
    l = line.replace(VAR_PLACE_HOLDER, function(match, p1) {
      return p1 ? varMap[p1] : match
    })
  }
  return l
}
function chkBgn(line, genType) {
  var result = BGN_MARKER.exec(line)
  if (result && result[1] == genType) {
    return true // BGN
  } else {
    return false
  }
}
function chkFin(line) {
  return FIN_MARKER.test(line)
}

function readAllLines(fpath, encode='utf8') {
  let lines = []
  // read contents of the file
  const data = fs.readFileSync(fpath, {encoding: encode});
  // split the contents by new line
  lines = data.split(/\r?\n/);
  return lines
}
